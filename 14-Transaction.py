# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.14.1
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

import pandas as pd
import numpy as np

# ## Подключение к бд

import sqlalchemy
# sqlalchemy.__version__

# # !pip install pyodbc
import pyodbc
import warnings
warnings.filterwarnings('ignore')

conn = pyodbc.connect('DSN=TestDB;Trusted_Connection=yes;')


def select(sql):
  return pd.read_sql(sql,conn)


cur = conn.cursor()
sql = '''
truncate table TestTable;
INSERT INTO TestTable VALUES 
    (1,'Клавиатура', 100), 
    (1, 'Мышь', 50), 
    (2, 'Телефон', 300);
    
truncate table TestTable2;    
INSERT INTO TestTable2 VALUES 
    ('Комплектующие компьютера'), 
    ('Мобильные устройства')     
'''
cur.execute(sql)
conn.commit()
cur.close()

# ## 157 Команды управления транзакциями

sql = '''SELECT * FROM TestTable'''
select(sql)

cur = conn.cursor()
sql = '''
BEGIN TRY
--Начало транзакции 
BEGIN TRANSACTION 
    --Инструкция 1 
    UPDATE TestTable SET CategoryId = 2 
    WHERE ProductId = 1 
    
    --Инструкция 2 
    UPDATE TestTable SET CategoryId = NULL 
    WHERE ProductId = 2 
    
    --...Другие инструкции 
END TRY 
    BEGIN CATCH 
        --В случае непредвиденной ошибки 
        --Откат транзакции 
        ROLLBACK TRANSACTION 
        
        --Выводим сообщение об ошибке 
        SELECT ERROR_NUMBER() AS [Номер ошибки], 
            ERROR_MESSAGE() AS [Описание ошибки] 
            
        --Прекращаем выполнение инструкции 
        RETURN; 
    END CATCH 
    
--Если все хорошо. Сохраняем все изменения 
COMMIT TRANSACTION
'''
cur.execute(sql)
conn.commit()
cur.close()

# 515          Не удалось вставить значение NULL в столбец "CategoryId", таблицы "TestDB.dbo.TestTable"; в столбце запрещены значения NULL. Ошибка в UPDATE.
#

sql = '''SELECT * FROM TestTable'''
select(sql)

# ## 158 Уровни изоляции

# **READ UNCOMMITTED** — самый низкий уровень, при котором SQL сервер разрешает так называемое «грязное чтение». Грязным чтением называют считывание неподтвержденных данных, иными словами, если транзакция, которая изменяет данные, не завершена, другая транзакция может получить уже измененные данные, хотя они еще не зафиксированы и могут отмениться.

# **READ COMMITTED** — этот уровень уже запрещает грязное чтение, в данном случае все процессы, запросившие данные, которые изменяются в тот же момент в другой транзакции, будут ждать завершения этой транзакции и подтверждения фиксации данных. Данный уровень по умолчанию используется SQL сервером.

# **REPEATABLE READ** – на данном уровне изоляции запрещается изменение данных между двумя операциями чтения в одной транзакции. Здесь происходит запрет на так называемое ***неповторяющееся чтение*** (или *несогласованный анализ*). Другими словами, если в одной транзакции есть несколько операций чтения, данные будут блокированы, и их нельзя будет изменить в другой транзакции. Таким образом, Вы избежите случаи, когда вначале транзакции Вы запросили данные, провели их анализ (некое вычисления), в конце транзакции запросили те же самые данные, а они уже отличаются от первоначальных, так как они были изменены другой транзакцией. Также уровень REPEATABLE READ запрещает «***Потерянное обновление***» - это когда две транзакции сначала считывают одни и те же данные, а затем изменяют их на основе неких вычислений, в результате обе транзакции выполнятся, но данные будут те, которая зафиксировала последняя операция обновления. Это происходит, потому что данные в операциях чтения в начале этих транзакций не были заблокированы. На данном уровне это исключено.

# **SERIALIZABLE** – данный уровень исключает чтение «*фантомных*» записей. Фантомные записи – это те записи, которые появились между началом и завершением транзакции. Иными словами, в начала транзакции Вы запросили определенные данные, в конце транзакции Вы запрашиваете их снова (с тем же фильтром), но там уже есть и новые данные, которые добавлены другой транзакцией. Более низкие уровни изоляции не блокировали строки, которых еще нет в таблице, данный уровень блокирует все строки, соответствующие фильтру запроса, с которыми будет работать транзакция, как существующие, так и те, что могут быть добавлены.

# Также существуют уровни изоляции, алгоритм которых основан на версиях строк, это: ***SNAPSHOT*** и ***READ COMMITTED SNAPSHOT***. Иными словами, SQL Server делает снимок, и, соответственно, хранит последние версии подтвержденных строк. В данном случае, клиенту не нужно ждать снятия блокировок, пока одна транзакция изменит данные, он сразу получает последнюю версию подтвержденных строк. Следует отметить, уровни изоляции, основанные на версиях строк, замедляют операции обновления и удаления,

# **SNAPSHOT** – уровень хранит строки, подтверждѐнные на момент начала транзакции, соответственно, именно эти строки будут считаны в случае обращения к ним из другой транзакции. Данный уровень исключает повторяющееся и фантомное чтение (*примерно так же, как уровень SERIALIZABLE*).

# **READ COMMITTED SNAPSHOT** – этот уровень изоляции работает практически так же, как уровень SNAPSHOT, с одним отличием, он хранит снимок строк, которые подтверждены на момент запуска команды, а не транзакции как в SNAPSHOT.

# Также для уровней SNAPSHOT и READ COMMITTED SNAPSHOT предварительно необходимо включить параметр базы данных ALLOW_SNAPSHOT_ISOLATION для уровня изоляции SNAPSHOT и READ_COMMITTED_SNAPSHOT для уровня READ COMMITTED SNAPSHOT. Например

cur = conn.cursor()
sql = '''
ALTER DATABASE TestDB SET ALLOW_SNAPSHOT_ISOLATION ON;
'''
cur.execute(sql)
conn.commit()
cur.close()

# ---

conn.close()


